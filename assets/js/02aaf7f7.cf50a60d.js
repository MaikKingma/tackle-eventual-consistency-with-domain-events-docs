"use strict";(self.webpackChunkclean_hexagonal_onion_docs=self.webpackChunkclean_hexagonal_onion_docs||[]).push([[124],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var i=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,i,s=function(e,t){if(null==e)return{};var n,i,s={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var c=i.createContext({}),l=function(e){var t=i.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=l(e.components);return i.createElement(c.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,s=e.mdxType,a=e.originalType,c=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),p=l(n),m=s,h=p["".concat(c,".").concat(m)]||p[m]||u[m]||a;return n?i.createElement(h,o(o({ref:t},d),{},{components:n})):i.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var a=n.length,o=new Array(a);o[0]=m;var r={};for(var c in t)hasOwnProperty.call(t,c)&&(r[c]=t[c]);r.originalType=e,r[p]="string"==typeof e?e:s,o[1]=r;for(var l=2;l<a;l++)o[l]=n[l];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6054:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var i=n(7462),s=(n(7294),n(3905));const a={sidebar_position:2},o="2: Theory - Eventual Consistency",r={unversionedId:"eventual-consistency",id:"eventual-consistency",title:"2: Theory - Eventual Consistency",description:"Eventual consistency is a consistency model used in both non-distributed and distributed systems to ensure data",source:"@site/docs/2.eventual-consistency.md",sourceDirName:".",slug:"/eventual-consistency",permalink:"/tackle-eventual-consistency-with-domain-events-docs/docs/eventual-consistency",draft:!1,editUrl:"https://github.com/MaikKingma/tackle-eventual-consistency-with-domain-events-docs/docs/2.eventual-consistency.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"1: Lab Intro",permalink:"/tackle-eventual-consistency-with-domain-events-docs/docs/intro"},next:{title:"3: Theory - Solutions",permalink:"/tackle-eventual-consistency-with-domain-events-docs/docs/Solutions"}},c={},l=[{value:"In a non-distributed system",id:"in-a-non-distributed-system",level:2},{value:"In a distributed system",id:"in-a-distributed-system",level:2},{value:"In the context of Domain Driven Design (DDD)",id:"in-the-context-of-domain-driven-design-ddd",level:2},{value:"Conflict resolution strategies",id:"conflict-resolution-strategies",level:2}],d={toc:l},p="wrapper";function u(e){let{components:t,...n}=e;return(0,s.kt)(p,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"2-theory---eventual-consistency"},"2: Theory - Eventual Consistency"),(0,s.kt)("p",null,"Eventual consistency is a consistency model used in both non-distributed and distributed systems to ensure data\nconsistency over time."),(0,s.kt)("h2",{id:"in-a-non-distributed-system"},"In a non-distributed system"),(0,s.kt)("p",null,"In a non-distributed system, eventual consistency refers to the state where the system may temporarily have inconsistent\ndata, but eventually reaches a consistent state as updates propagate through the system. This can occur due to factors\nsuch as caching, background processing, or asynchronous updates. The system tolerates temporary inconsistencies in favor\nof performance or availability, with the expectation that the system will converge to a consistent state over time."),(0,s.kt)("h2",{id:"in-a-distributed-system"},"In a distributed system"),(0,s.kt)("p",null,"In a distributed system, eventual consistency is a more prominent concept, as it involves data replication and\npartitioning across multiple nodes. This model allows the system to prioritize high availability and performance\nby allowing temporary inconsistencies between replicas. Updates propagate asynchronously across nodes, and the system\neventually reaches a consistent state once all updates have been spread and applied. While providing advantages\nin terms of scalability and fault tolerance, eventual consistency can pose challenges in application design, as it\nrequires handling potential data inconsistencies and conflicts."),(0,s.kt)("h2",{id:"in-the-context-of-domain-driven-design-ddd"},"In the context of Domain Driven Design (DDD)"),(0,s.kt)("p",null,"Eventual consistency, when combined with Domain-Driven Design (DDD) and its concept of domain events, can provide a\nrobust approach to managing data consistency and system complexity in both non-distributed and distributed systems."),(0,s.kt)("p",null,"Domain events are significant occurrences within a system's domain that capture the result of a business operation or a\nstate change. They are used to decouple components and propagate information about changes in the domain, which helps\nin managing the complexity of the system."),(0,s.kt)("p",null,"In a non-distributed system, domain events can be used in conjunction with eventual consistency to improve system\nresponsiveness and maintainability. Instead of immediately applying changes to the data, the system can emit domain\nevents that represent the business operation's outcome. These events can then be asynchronously processed by event\nhandlers, which update the system's state or trigger further actions. This approach allows for temporary inconsistencies\nin the system, but it will eventually reach a consistent state once all events are processed."),(0,s.kt)("p",null,"In a distributed system, domain events play a more critical role in achieving eventual consistency. As the system is\ncomposed of multiple nodes, domain events serve as a communication mechanism to propagate state changes between nodes.\nThis helps to maintain consistency across replicas in the face of network latency, partitioning, or node failures.\nBy leveraging domain events, a distributed system can achieve high availability and fault tolerance while ensuring that\nthe system converges to a consistent state over time."),(0,s.kt)("p",null,"However, using domain events and eventual consistency in both non-distributed and distributed systems introduces\ncomplexities in application design. Developers need to consider the implications of eventual consistency when designing\ndomain models, event handlers, and conflict resolution strategies. This requires a deep understanding of the domain, its\ninvariants, and the trade-offs between consistency, performance, and availability."),(0,s.kt)("h2",{id:"conflict-resolution-strategies"},"Conflict resolution strategies"),(0,s.kt)("p",null,"Conflict resolution strategies in event-driven distributed systems deal with the problem of handling conflicting updates\nto the same piece of data. This is especially crucial in eventual consistency models where data is not immediately\nconsistent across all nodes in the system but becomes consistent over time."),(0,s.kt)("p",null,"Here are a few commonly used conflict resolution strategies:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Last Write Wins (LWW):"),' This is the simplest strategy where the latest update is considered as the winner. However,\nthis method can often lead to data loss if the system clock is not perfectly synchronized across all nodes, or if\nupdates occur so close together that the "last" write isn\'t clearly defined.')),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Source priority:")," In this approach, each source or node in a distributed system is assigned a priority. In the\nevent of a conflict, the update from the higher priority source is chosen. However, this approach can be problematic\nif a high-priority source starts generating incorrect updates.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Operational transformation (OT):")," This strategy is often used in real-time collaborative applications (like Google\nDocs). The main idea is to transform operations so that the order of execution does not matter. For example, if one\noperation is \"add 'a' at position 0\" and another operation is \"add 'b' at position 1\", it doesn't matter which\noperation is executed first.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Conflict-free replicated data types (CRDTs):"),' CRDTs are data structures that allow concurrent updates from\ndifferent\nnodes, and they can automatically resolve conflicts in a deterministic manner. There are two types of CRDTs:\noperation-based (where operations are reliably broadcast to all replicas) and state-based (where state is merged by\ntaking the "join" of two states).')),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Version vectors/Vector clocks:")," These are used to track the causality of events. If two events are concurrent and\nconflict, a decision needs to be made. This could be based on a simple policy like LWW, or a more complex one based on\nthe application's needs.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Application-specific conflict resolution:")," Sometimes, the nature of the data or the application can guide the\nconflict\nresolution. For example, in a banking application, if two conflicting transactions are detected, the system might\nresolve the conflict by aborting one transaction and retrying it later."))),(0,s.kt)("p",null,"The best conflict resolution strategy often depends on the specific requirements of your system and the nature of your\ndata."))}u.isMDXComponent=!0}}]);